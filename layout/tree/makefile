CXX=g++
CFLAGS=-g -std=c++20

SRC=$(wildcard *.cpp)
TARGET=$(patsubst %.cpp,%.out,$(SRC))

main.out : main.cpp walk.h draw_tree.hpp
	$(CXX) $(CFLAGS) -o $@ $< -I../../include/
	./$@ < in

tidy.out : tidyDraw.cpp tidy.hpp draw_tree.hpp
	$(CXX) $(CFLAGS) -o $@ $< -I../../include/
	./$@

# all: $(TARGET)
# 	@echo done
#
# %.out : %.cpp
# 	$(CXX) $(CFLAGS) -o $@ $<
# 	./$@
#
clean:
	rm -rf main.out
#$@  表示目标文件
#$^  表示所有的依赖文件
#$<  表示第一个依赖文件
#$?  表示比目标还要新的依赖文件列表

#$% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是“foo.a(bar.o)”，那么，“$%”就是“bar.o”，“$@”就是“foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。

#$+ 这个变量很像“$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。

# $* 这个变量表示目标模式中“%”及其之前的部分。如果目标是“dir/a.foo.b”，并且目标的模式是“a.%.b”，那么，“$*”的值就是“dir/a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么“$*”也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么“$*”就是除了后缀的那一部分。例如：如果目标是“foo.c”，因为“.c”是make所能识别的后缀名，所以，“$*”的值就是“foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用“$*”，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么“$*”就是空值。
